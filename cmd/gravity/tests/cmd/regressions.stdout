// Code generated by arcjet-gravity; DO NOT EDIT.

package regressions

import "context"
import "errors"
import "github.com/tetratelabs/wazero"
import "github.com/tetratelabs/wazero/api"

import _ "embed"

//go:embed regressions.wasm
var wasmFileRegressions []byte

type IRegressionsChecker interface {
	IsEnabled(
		ctx context.Context,
		key string,
	) bool
	GetStatus(
		ctx context.Context,
		key string,
	) Status
}

type Status interface {
	isStatus()
}

type status int

func (status) isStatus() {}

const (
	Active status = iota
	Inactive status = iota
	Unknown status = iota
)

type IRegressionsProcessor interface {
	Double(
		ctx context.Context,
		value uint32,
	) uint32
}

type IRegressionsPinger interface {
	Ping(
		ctx context.Context,
	) bool
}

type RegressionsFactory struct {
	runtime wazero.Runtime
	module wazero.CompiledModule
}

func NewRegressionsFactory(
	ctx context.Context,
	checker IRegressionsChecker,
	processor IRegressionsProcessor,
	pinger IRegressionsPinger,
) (*RegressionsFactory, error) {
	wazeroRuntime := wazero.NewRuntime(ctx)

	_, err0 := wazeroRuntime.NewHostModuleBuilder("gravity:regressions/checker").
	NewFunctionBuilder().
	WithFunc(func(
		ctx context.Context,
		mod api.Module,
		arg0 uint32,
		arg1 uint32,
	) uint32{
		buf0, ok0 := mod.Memory().Read(arg0, arg1)
		if !ok0 {
			panic(errors.New("failed to read bytes from memory"))
		}
		str0 := string(buf0)
		value1 := checker.IsEnabled(ctx, str0)
		var value2 uint32
		if value1 {
			value2 = 1
		} else {
			value2 = 0
		}
		return value2
	}).
	Export("is-enabled").
	NewFunctionBuilder().
	WithFunc(func(
		ctx context.Context,
		mod api.Module,
		arg0 uint32,
		arg1 uint32,
	) uint32{
		buf0, ok0 := mod.Memory().Read(arg0, arg1)
		if !ok0 {
			panic(errors.New("failed to read bytes from memory"))
		}
		str0 := string(buf0)
		value1 := checker.GetStatus(ctx, str0)
		var enum2 uint32
		switch value1 {
		case Active:
			enum2 = 0
		case Inactive:
			enum2 = 1
		case Unknown:
			enum2 = 2
		default:
			panic(errors.New("invalid enum type provided"))
		}
		return enum2
	}).
	Export("get-status").
	Instantiate(ctx)
	if err0 != nil {
		return nil, err0
	}
	_, err2 := wazeroRuntime.NewHostModuleBuilder("gravity:regressions/pinger").
	NewFunctionBuilder().
	WithFunc(func(
		ctx context.Context,
		mod api.Module,
	) uint32{
		value0 := pinger.Ping(ctx, )
		var value1 uint32
		if value0 {
			value1 = 1
		} else {
			value1 = 0
		}
		return value1
	}).
	Export("ping").
	Instantiate(ctx)
	if err2 != nil {
		return nil, err2
	}
	_, err1 := wazeroRuntime.NewHostModuleBuilder("gravity:regressions/processor").
	NewFunctionBuilder().
	WithFunc(func(
		ctx context.Context,
		mod api.Module,
		arg0 uint32,
	) uint32{
		result0 := uint32(arg0)
		value1 := processor.Double(ctx, result0)
		result2 := uint32(value1)
		return result2
	}).
	Export("double").
	Instantiate(ctx)
	if err1 != nil {
		return nil, err1
	}

	// Compiling the module takes a LONG time, so we want to do it once and hold
	// onto it with the Runtime
	module, err := wazeroRuntime.CompileModule(ctx, wasmFileRegressions)
	if err != nil {
		return nil, err
	}
	return &RegressionsFactory{
		runtime: wazeroRuntime,
		module: module,
	}, nil
}

func (f *RegressionsFactory) Instantiate(ctx context.Context) (*RegressionsInstance, error) {
	if module, err := f.runtime.InstantiateModule(ctx, f.module, wazero.NewModuleConfig()); err != nil {
		return nil, err
	} else {
		return &RegressionsInstance{module}, nil
	}
}

func (f *RegressionsFactory) Close(ctx context.Context) {
	f.runtime.Close(ctx)
}

type RegressionsInstance struct {
	module api.Module
}

func (i *RegressionsInstance) Close(ctx context.Context) error {
	if err := i.module.Close(ctx); err != nil {
		return err
	}

	return nil
}

// writeString will put a Go string into the Wasm memory following the Component
// Model calling conventions, such as allocating memory with the realloc function
func writeString(
	ctx context.Context,
	s string,
	memory api.Memory,
	realloc api.Function,
) (uint64, uint64, error) {
	if len(s) == 0 {
		return 1, 0, nil
	}

	results, err := realloc.Call(ctx, 0, 0, 1, uint64(len(s)))
	if err != nil {
		return 1, 0, err
	}
	ptr := results[0]
	ok := memory.Write(uint32(ptr), []byte(s))
	if !ok {
		return 1, 0, errors.New("failed to write string to wasm memory")
	}
	return uint64(ptr), uint64(len(s)), nil
}

func (i *RegressionsInstance) CheckEnabled(
	ctx context.Context,
	key string,
) bool {
	arg0 := key
	memory0 := i.module.Memory()
	realloc0 := i.module.ExportedFunction("cabi_realloc")
	ptr0, len0, err0 := writeString(ctx, arg0, memory0, realloc0)
	// The return type doesn't contain an error so we panic if one is encountered
	if err0 != nil {
		panic(err0)
	}
	raw1, err1 := i.module.ExportedFunction("check-enabled").Call(ctx, uint64(ptr0), uint64(len0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	value2 := results1 != 0
	return value2
}

func (i *RegressionsInstance) CheckStatus(
	ctx context.Context,
	key string,
) uint32 {
	arg0 := key
	memory0 := i.module.Memory()
	realloc0 := i.module.ExportedFunction("cabi_realloc")
	ptr0, len0, err0 := writeString(ctx, arg0, memory0, realloc0)
	// The return type doesn't contain an error so we panic if one is encountered
	if err0 != nil {
		panic(err0)
	}
	raw1, err1 := i.module.ExportedFunction("check-status").Call(ctx, uint64(ptr0), uint64(len0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	result2 := uint32(results1)
	return result2
}

func (i *RegressionsInstance) DoubleValue(
	ctx context.Context,
	value uint32,
) uint32 {
	arg0 := value
	result0 := uint32(arg0)
	raw1, err1 := i.module.ExportedFunction("double-value").Call(ctx, uint64(result0))
	// The return type doesn't contain an error so we panic if one is encountered
	if err1 != nil {
		panic(err1)
	}

	results1 := raw1[0]
	result2 := uint32(results1)
	return result2
}

func (i *RegressionsInstance) RunPing(
	ctx context.Context,
) bool {
	raw0, err0 := i.module.ExportedFunction("run-ping").Call(ctx, )
	// The return type doesn't contain an error so we panic if one is encountered
	if err0 != nil {
		panic(err0)
	}

	results0 := raw0[0]
	value1 := results0 != 0
	return value1
}

