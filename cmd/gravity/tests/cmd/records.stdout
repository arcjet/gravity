// Code generated by arcjet-gravity; DO NOT EDIT.

package records

import "context"
import "errors"
import "github.com/tetratelabs/wazero"
import "github.com/tetratelabs/wazero/api"

import _ "embed"

//go:embed records.wasm
var wasmFileRecords []byte

type Foo struct {
	Float32 float32

	Float64 float64

	Uint32 uint32

	Uint64 uint64

	S string

	Vf32 []float32

	Vf64 []float64
}

type RecordsFactory struct {
	runtime wazero.Runtime
	module wazero.CompiledModule
}

func NewRecordsFactory(
	ctx context.Context,
) (*RecordsFactory, error) {
	wazeroRuntime := wazero.NewRuntime(ctx)

	// Compiling the module takes a LONG time, so we want to do it once and hold
	// onto it with the Runtime
	module, err := wazeroRuntime.CompileModule(ctx, wasmFileRecords)
	if err != nil {
		return nil, err
	}
	return &RecordsFactory{
		runtime: wazeroRuntime,
		module: module,
	}, nil
}

func (f *RecordsFactory) Instantiate(ctx context.Context) (*RecordsInstance, error) {
	if module, err := f.runtime.InstantiateModule(ctx, f.module, wazero.NewModuleConfig()); err != nil {
		return nil, err
	} else {
		return &RecordsInstance{module}, nil
	}
}

func (f *RecordsFactory) Close(ctx context.Context) {
	f.runtime.Close(ctx)
}

type RecordsInstance struct {
	module api.Module
}

func (i *RecordsInstance) Close(ctx context.Context) error {
	if err := i.module.Close(ctx); err != nil {
		return err
	}

	return nil
}

// writeString will put a Go string into the Wasm memory following the Component
// Model calling conventions, such as allocating memory with the realloc function
func writeString(
	ctx context.Context,
	s string,
	memory api.Memory,
	realloc api.Function,
) (uint64, uint64, error) {
	if len(s) == 0 {
		return 1, 0, nil
	}

	results, err := realloc.Call(ctx, 0, 0, 1, uint64(len(s)))
	if err != nil {
		return 1, 0, err
	}
	ptr := results[0]
	ok := memory.Write(uint32(ptr), []byte(s))
	if !ok {
		return 1, 0, errors.New("failed to write string to wasm memory")
	}
	return uint64(ptr), uint64(len(s)), nil
}

func (i *RecordsInstance) ModifyFoo(
	ctx context.Context,
	f Foo,
) Foo {
	arg0 := f
	float320 := arg0.Float32
	float640 := arg0.Float64
	uint320 := arg0.Uint32
	uint640 := arg0.Uint64
	s0 := arg0.S
	vf320 := arg0.Vf32
	vf640 := arg0.Vf64
	result1 := api.EncodeF32(float320)
	result2 := api.EncodeF64(float640)
	result3 := api.EncodeU32(uint320)
	value4 := int64(uint640)
	memory5 := i.module.Memory()
	realloc5 := i.module.ExportedFunction("cabi_realloc")
	ptr5, len5, err5 := writeString(ctx, s0, memory5, realloc5)
	// The return type doesn't contain an error so we panic if one is encountered
	if err5 != nil {
		panic(err5)
	}
	vec7 := vf320
	len7 := uint64(len(vec7))
	result7, err7 := i.module.ExportedFunction("cabi_realloc").Call(ctx, 0, 0, 4, len7 * 4)
	// The return type doesn't contain an error so we panic if one is encountered
	if err7 != nil {
		panic(err7)
	}
	ptr7 := result7[0]
	for idx := uint64(0); idx < len7; idx++ {
		e := vec7[idx]
		base := uint32(ptr7 + uint64(idx) * uint64(4))
		result6 := api.EncodeF32(e)
		i.module.Memory().WriteUint64Le(base+0, result6)
	}
	vec9 := vf640
	len9 := uint64(len(vec9))
	result9, err9 := i.module.ExportedFunction("cabi_realloc").Call(ctx, 0, 0, 8, len9 * 8)
	// The return type doesn't contain an error so we panic if one is encountered
	if err9 != nil {
		panic(err9)
	}
	ptr9 := result9[0]
	for idx := uint64(0); idx < len9; idx++ {
		e := vec9[idx]
		base := uint32(ptr9 + uint64(idx) * uint64(8))
		result8 := api.EncodeF64(e)
		i.module.Memory().WriteUint64Le(base+0, result8)
	}
	raw10, err10 := i.module.ExportedFunction("modify-foo").Call(ctx, uint64(result1), uint64(result2), uint64(result3), uint64(value4), uint64(ptr5), uint64(len5), uint64(ptr7), uint64(len7), uint64(ptr9), uint64(len9))
	// The return type doesn't contain an error so we panic if one is encountered
	if err10 != nil {
		panic(err10)
	}

	// The cleanup via `cabi_post_*` cleans up the memory in the guest. By
	// deferring this, we ensure that no memory is corrupted before the function
	// is done accessing it.
	defer func() {
		if _, err := i.module.ExportedFunction("cabi_post_modify-foo").Call(ctx, raw10...); err != nil {
			// If we get an error during cleanup, something really bad is
			// going on, so we panic. Also, you can't return the error from
			// the `defer`
			panic(errors.New("failed to cleanup"))
		}
	}()

	results10 := raw10[0]
	value11, ok11 := i.module.Memory().ReadUint64Le(uint32(results10 + 0))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok11 {
		panic(errors.New("failed to read f32 from memory"))
	}
	result12 := api.DecodeF32(value11)
	value13, ok13 := i.module.Memory().ReadUint64Le(uint32(results10 + 8))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok13 {
		panic(errors.New("failed to read f64 from memory"))
	}
	result14 := api.DecodeF64(value13)
	value15, ok15 := i.module.Memory().ReadUint32Le(uint32(results10 + 16))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok15 {
		panic(errors.New("failed to read i32 from memory"))
	}
	result16 := api.DecodeU32(uint64(value15))
	value17, ok17 := i.module.Memory().ReadUint64Le(uint32(results10 + 24))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok17 {
		panic(errors.New("failed to read i64 from memory"))
	}
	value18 := uint64(value17)
	ptr19, ok19 := i.module.Memory().ReadUint32Le(uint32(results10 + 32))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok19 {
		panic(errors.New("failed to read pointer from memory"))
	}
	len20, ok20 := i.module.Memory().ReadUint32Le(uint32(results10 + 36))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok20 {
		panic(errors.New("failed to read length from memory"))
	}
	buf21, ok21 := i.module.Memory().Read(ptr19, len20)
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok21 {
		panic(errors.New("failed to read bytes from memory"))
	}
	str21 := string(buf21)
	ptr22, ok22 := i.module.Memory().ReadUint32Le(uint32(results10 + 40))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok22 {
		panic(errors.New("failed to read pointer from memory"))
	}
	len23, ok23 := i.module.Memory().ReadUint32Le(uint32(results10 + 44))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok23 {
		panic(errors.New("failed to read length from memory"))
	}
	base26 := ptr22
	len26 := len23
	result26 := make([]float32, len26)
	for idx26 := uint32(0); idx26 < len26; idx26++ {
		base := base26 + idx26 * 4
		value24, ok24 := i.module.Memory().ReadUint64Le(uint32(base + 0))
		// The return type doesn't contain an error so we panic if one is encountered
		if !ok24 {
			panic(errors.New("failed to read f32 from memory"))
		}
		result25 := api.DecodeF32(value24)
		result26[idx26] = result25
	}
	ptr27, ok27 := i.module.Memory().ReadUint32Le(uint32(results10 + 48))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok27 {
		panic(errors.New("failed to read pointer from memory"))
	}
	len28, ok28 := i.module.Memory().ReadUint32Le(uint32(results10 + 52))
	// The return type doesn't contain an error so we panic if one is encountered
	if !ok28 {
		panic(errors.New("failed to read length from memory"))
	}
	base31 := ptr27
	len31 := len28
	result31 := make([]float64, len31)
	for idx31 := uint32(0); idx31 < len31; idx31++ {
		base := base31 + idx31 * 8
		value29, ok29 := i.module.Memory().ReadUint64Le(uint32(base + 0))
		// The return type doesn't contain an error so we panic if one is encountered
		if !ok29 {
			panic(errors.New("failed to read f64 from memory"))
		}
		result30 := api.DecodeF64(value29)
		result31[idx31] = result30
	}
	value32 := Foo{
		Float32: result12,
		Float64: result14,
		Uint32: result16,
		Uint64: value18,
		S: str21,
		Vf32: result26,
		Vf64: result31,
	}
	return value32
}

func (i *RecordsInstance) ModifyFooFallible(
	ctx context.Context,
	f Foo,
) (Foo, error) {
	arg0 := f
	float320 := arg0.Float32
	float640 := arg0.Float64
	uint320 := arg0.Uint32
	uint640 := arg0.Uint64
	s0 := arg0.S
	vf320 := arg0.Vf32
	vf640 := arg0.Vf64
	result1 := api.EncodeF32(float320)
	result2 := api.EncodeF64(float640)
	result3 := api.EncodeU32(uint320)
	value4 := int64(uint640)
	memory5 := i.module.Memory()
	realloc5 := i.module.ExportedFunction("cabi_realloc")
	ptr5, len5, err5 := writeString(ctx, s0, memory5, realloc5)
	if err5 != nil {
		var default5 Foo
		return default5, err5
	}
	vec7 := vf320
	len7 := uint64(len(vec7))
	result7, err7 := i.module.ExportedFunction("cabi_realloc").Call(ctx, 0, 0, 4, len7 * 4)
	if err7 != nil {
		var default7 Foo
		return default7, err7
	}
	ptr7 := result7[0]
	for idx := uint64(0); idx < len7; idx++ {
		e := vec7[idx]
		base := uint32(ptr7 + uint64(idx) * uint64(4))
		result6 := api.EncodeF32(e)
		i.module.Memory().WriteUint64Le(base+0, result6)
	}
	vec9 := vf640
	len9 := uint64(len(vec9))
	result9, err9 := i.module.ExportedFunction("cabi_realloc").Call(ctx, 0, 0, 8, len9 * 8)
	if err9 != nil {
		var default9 Foo
		return default9, err9
	}
	ptr9 := result9[0]
	for idx := uint64(0); idx < len9; idx++ {
		e := vec9[idx]
		base := uint32(ptr9 + uint64(idx) * uint64(8))
		result8 := api.EncodeF64(e)
		i.module.Memory().WriteUint64Le(base+0, result8)
	}
	raw10, err10 := i.module.ExportedFunction("modify-foo-fallible").Call(ctx, uint64(result1), uint64(result2), uint64(result3), uint64(value4), uint64(ptr5), uint64(len5), uint64(ptr7), uint64(len7), uint64(ptr9), uint64(len9))
	if err10 != nil {
		var default10 Foo
		return default10, err10
	}

	// The cleanup via `cabi_post_*` cleans up the memory in the guest. By
	// deferring this, we ensure that no memory is corrupted before the function
	// is done accessing it.
	defer func() {
		if _, err := i.module.ExportedFunction("cabi_post_modify-foo-fallible").Call(ctx, raw10...); err != nil {
			// If we get an error during cleanup, something really bad is
			// going on, so we panic. Also, you can't return the error from
			// the `defer`
			panic(errors.New("failed to cleanup"))
		}
	}()

	results10 := raw10[0]
	value11, ok11 := i.module.Memory().ReadByte(uint32(results10 + 0))
	if !ok11 {
		var default11 Foo
		return default11, errors.New("failed to read byte from memory")
	}
	var value37 Foo
	var err37 error
	switch value11 {
	case 0:
		value12, ok12 := i.module.Memory().ReadUint64Le(uint32(results10 + 8))
		if !ok12 {
			var default12 Foo
			return default12, errors.New("failed to read f32 from memory")
		}
		result13 := api.DecodeF32(value12)
		value14, ok14 := i.module.Memory().ReadUint64Le(uint32(results10 + 16))
		if !ok14 {
			var default14 Foo
			return default14, errors.New("failed to read f64 from memory")
		}
		result15 := api.DecodeF64(value14)
		value16, ok16 := i.module.Memory().ReadUint32Le(uint32(results10 + 24))
		if !ok16 {
			var default16 Foo
			return default16, errors.New("failed to read i32 from memory")
		}
		result17 := api.DecodeU32(uint64(value16))
		value18, ok18 := i.module.Memory().ReadUint64Le(uint32(results10 + 32))
		if !ok18 {
			var default18 Foo
			return default18, errors.New("failed to read i64 from memory")
		}
		value19 := uint64(value18)
		ptr20, ok20 := i.module.Memory().ReadUint32Le(uint32(results10 + 40))
		if !ok20 {
			var default20 Foo
			return default20, errors.New("failed to read pointer from memory")
		}
		len21, ok21 := i.module.Memory().ReadUint32Le(uint32(results10 + 44))
		if !ok21 {
			var default21 Foo
			return default21, errors.New("failed to read length from memory")
		}
		buf22, ok22 := i.module.Memory().Read(ptr20, len21)
		if !ok22 {
			var default22 Foo
			return default22, errors.New("failed to read bytes from memory")
		}
		str22 := string(buf22)
		ptr23, ok23 := i.module.Memory().ReadUint32Le(uint32(results10 + 48))
		if !ok23 {
			var default23 Foo
			return default23, errors.New("failed to read pointer from memory")
		}
		len24, ok24 := i.module.Memory().ReadUint32Le(uint32(results10 + 52))
		if !ok24 {
			var default24 Foo
			return default24, errors.New("failed to read length from memory")
		}
		base27 := ptr23
		len27 := len24
		result27 := make([]float32, len27)
		for idx27 := uint32(0); idx27 < len27; idx27++ {
			base := base27 + idx27 * 4
			value25, ok25 := i.module.Memory().ReadUint64Le(uint32(base + 0))
			if !ok25 {
				var default25 Foo
				return default25, errors.New("failed to read f32 from memory")
			}
			result26 := api.DecodeF32(value25)
			result27[idx27] = result26
		}
		ptr28, ok28 := i.module.Memory().ReadUint32Le(uint32(results10 + 56))
		if !ok28 {
			var default28 Foo
			return default28, errors.New("failed to read pointer from memory")
		}
		len29, ok29 := i.module.Memory().ReadUint32Le(uint32(results10 + 60))
		if !ok29 {
			var default29 Foo
			return default29, errors.New("failed to read length from memory")
		}
		base32 := ptr28
		len32 := len29
		result32 := make([]float64, len32)
		for idx32 := uint32(0); idx32 < len32; idx32++ {
			base := base32 + idx32 * 8
			value30, ok30 := i.module.Memory().ReadUint64Le(uint32(base + 0))
			if !ok30 {
				var default30 Foo
				return default30, errors.New("failed to read f64 from memory")
			}
			result31 := api.DecodeF64(value30)
			result32[idx32] = result31
		}
		value33 := Foo{
			Float32: result13,
			Float64: result15,
			Uint32: result17,
			Uint64: value19,
			S: str22,
			Vf32: result27,
			Vf64: result32,
		}
		value37 = value33
	case 1:
		ptr34, ok34 := i.module.Memory().ReadUint32Le(uint32(results10 + 8))
		if !ok34 {
			var default34 Foo
			return default34, errors.New("failed to read pointer from memory")
		}
		len35, ok35 := i.module.Memory().ReadUint32Le(uint32(results10 + 12))
		if !ok35 {
			var default35 Foo
			return default35, errors.New("failed to read length from memory")
		}
		buf36, ok36 := i.module.Memory().Read(ptr34, len35)
		if !ok36 {
			var default36 Foo
			return default36, errors.New("failed to read bytes from memory")
		}
		str36 := string(buf36)
		err37 = errors.New(str36)
	default:
		err37 = errors.New("invalid variant discriminant for expected")
	}
	return value37, err37
}

