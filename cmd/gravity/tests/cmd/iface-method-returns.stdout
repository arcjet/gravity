// Code generated by arcjet-gravity; DO NOT EDIT.

package example

import "context"
import "errors"
import "github.com/tetratelabs/wazero"
import "github.com/tetratelabs/wazero/api"

import _ "embed"

//go:embed example.wasm
var wasmFileExample []byte

type IExampleRuntime interface {
	Os(
		ctx context.Context,
	) string
	Arch(
		ctx context.Context,
	) string
	GetU32(
		ctx context.Context,
	) uint32
	Puts(
		ctx context.Context,
		msg string,
	)
}

type ExampleFactory struct {
	runtime wazero.Runtime
	module wazero.CompiledModule
}

func NewExampleFactory(
	ctx context.Context,
	runtime IExampleRuntime,
) (*ExampleFactory, error) {
	wazeroRuntime := wazero.NewRuntime(ctx)

	_, err0 := wazeroRuntime.NewHostModuleBuilder("arcjet:example/runtime").
	NewFunctionBuilder().
	WithGoModuleFunction(
		api.GoModuleFunc(func(
			ctx context.Context,
			mod api.Module,
			stack []uint64,
		) {
			value0 := runtime.Os(ctx, )
			arg0 := stack[0]
			memory1 := mod.Memory()
			realloc1 := mod.ExportedFunction("cabi_realloc")
			ptr1, len1, err1 := writeString(ctx, value0, memory1, realloc1)
			if err1 != nil {
				panic(err1)
			}
			ptr2 := api.DecodeU32(arg0)
			mod.Memory().WriteUint32Le(ptr2+4, uint32(len1))
			ptr3 := api.DecodeU32(arg0)
			mod.Memory().WriteUint32Le(ptr3+0, uint32(ptr1))
		}),
		[]api.ValueType{
			api.ValueTypeI32,
		},
		[]api.ValueType{},
	).
	Export("os").
	NewFunctionBuilder().
	WithGoModuleFunction(
		api.GoModuleFunc(func(
			ctx context.Context,
			mod api.Module,
			stack []uint64,
		) {
			value0 := runtime.Arch(ctx, )
			arg0 := stack[0]
			memory1 := mod.Memory()
			realloc1 := mod.ExportedFunction("cabi_realloc")
			ptr1, len1, err1 := writeString(ctx, value0, memory1, realloc1)
			if err1 != nil {
				panic(err1)
			}
			ptr2 := api.DecodeU32(arg0)
			mod.Memory().WriteUint32Le(ptr2+4, uint32(len1))
			ptr3 := api.DecodeU32(arg0)
			mod.Memory().WriteUint32Le(ptr3+0, uint32(ptr1))
		}),
		[]api.ValueType{
			api.ValueTypeI32,
		},
		[]api.ValueType{},
	).
	Export("arch").
	NewFunctionBuilder().
	WithGoModuleFunction(
		api.GoModuleFunc(func(
			ctx context.Context,
			mod api.Module,
			stack []uint64,
		) {
			value0 := runtime.GetU32(ctx, )
			result1 := api.EncodeU32(value0)
			stack[0] = result1
		}),
		[]api.ValueType{},
		[]api.ValueType{
			api.ValueTypeI32,
		},
	).
	Export("get-u32").
	NewFunctionBuilder().
	WithGoModuleFunction(
		api.GoModuleFunc(func(
			ctx context.Context,
			mod api.Module,
			stack []uint64,
		) {
			arg0 := stack[0]
			arg1 := stack[1]
			ptr0 := api.DecodeU32(arg0)
			len0 := api.DecodeU32(arg1)
			buf0, ok0 := mod.Memory().Read(ptr0, len0)
			if !ok0 {
				panic(errors.New("failed to read bytes from memory"))
			}
			str0 := string(buf0)
			runtime.Puts(ctx, str0)
		}),
		[]api.ValueType{
			api.ValueTypeI32,
			api.ValueTypeI32,
		},
		[]api.ValueType{},
	).
	Export("puts").
	Instantiate(ctx)
	if err0 != nil {
		return nil, err0
	}

	// Compiling the module takes a LONG time, so we want to do it once and hold
	// onto it with the Runtime
	module, err := wazeroRuntime.CompileModule(ctx, wasmFileExample)
	if err != nil {
		return nil, err
	}
	return &ExampleFactory{
		runtime: wazeroRuntime,
		module: module,
	}, nil
}

func (f *ExampleFactory) Instantiate(ctx context.Context) (*ExampleInstance, error) {
	if module, err := f.runtime.InstantiateModule(ctx, f.module, wazero.NewModuleConfig()); err != nil {
		return nil, err
	} else {
		return &ExampleInstance{module}, nil
	}
}

func (f *ExampleFactory) Close(ctx context.Context) {
	f.runtime.Close(ctx)
}

type ExampleInstance struct {
	module api.Module
}

func (i *ExampleInstance) Close(ctx context.Context) error {
	if err := i.module.Close(ctx); err != nil {
		return err
	}

	return nil
}

// writeString will put a Go string into the Wasm memory following the Component
// Model calling conventions, such as allocating memory with the realloc function
func writeString(
	ctx context.Context,
	s string,
	memory api.Memory,
	realloc api.Function,
) (uint64, uint64, error) {
	if len(s) == 0 {
		return 1, 0, nil
	}

	results, err := realloc.Call(ctx, 0, 0, 1, uint64(len(s)))
	if err != nil {
		return 1, 0, err
	}
	ptr := results[0]
	ok := memory.Write(uint32(ptr), []byte(s))
	if !ok {
		return 1, 0, errors.New("failed to write string to wasm memory")
	}
	return uint64(ptr), uint64(len(s)), nil
}

func (i *ExampleInstance) Hello(
	ctx context.Context,
) (string, error) {
	raw0, err0 := i.module.ExportedFunction("hello").Call(ctx, )
	if err0 != nil {
		var default0 string
		return default0, err0
	}

	// The cleanup via `cabi_post_*` cleans up the memory in the guest. By
	// deferring this, we ensure that no memory is corrupted before the function
	// is done accessing it.
	defer func() {
		if postFn := i.module.ExportedFunction("cabi_post_hello"); postFn != nil {
			if _, err := postFn.Call(ctx, raw0...); err != nil {
				// If we get an error during cleanup, something really bad is
				// going on, so we panic. Also, you can't return the error from
				// the `defer`
				panic(errors.New("failed to cleanup"))
			}
		}
	}()

	results0 := raw0[0]
	value1, ok1 := i.module.Memory().ReadByte(uint32(results0 + 0))
	if !ok1 {
		var default1 string
		return default1, errors.New("failed to read byte from memory")
	}
	var value8 string
	var err8 error
	switch value1 {
	case 0:
		ptr2, ok2 := i.module.Memory().ReadUint32Le(uint32(results0 + 4))
		if !ok2 {
			var default2 string
			return default2, errors.New("failed to read pointer from memory")
		}
		len3, ok3 := i.module.Memory().ReadUint32Le(uint32(results0 + 8))
		if !ok3 {
			var default3 string
			return default3, errors.New("failed to read length from memory")
		}
		buf4, ok4 := i.module.Memory().Read(ptr2, len3)
		if !ok4 {
			var default4 string
			return default4, errors.New("failed to read bytes from memory")
		}
		str4 := string(buf4)
		value8 = str4
	case 1:
		ptr5, ok5 := i.module.Memory().ReadUint32Le(uint32(results0 + 4))
		if !ok5 {
			var default5 string
			return default5, errors.New("failed to read pointer from memory")
		}
		len6, ok6 := i.module.Memory().ReadUint32Le(uint32(results0 + 8))
		if !ok6 {
			var default6 string
			return default6, errors.New("failed to read length from memory")
		}
		buf7, ok7 := i.module.Memory().Read(ptr5, len6)
		if !ok7 {
			var default7 string
			return default7, errors.New("failed to read bytes from memory")
		}
		str7 := string(buf7)
		err8 = errors.New(str7)
	default:
		err8 = errors.New("invalid variant discriminant for expected")
	}
	return value8, err8
}

func (i *ExampleInstance) CallGetU32(
	ctx context.Context,
) uint32 {
	raw0, err0 := i.module.ExportedFunction("call-get-u32").Call(ctx, )
	// The return type doesn't contain an error so we panic if one is encountered
	if err0 != nil {
		panic(err0)
	}

	results0 := raw0[0]
	result1 := api.DecodeU32(results0)
	return result1
}

